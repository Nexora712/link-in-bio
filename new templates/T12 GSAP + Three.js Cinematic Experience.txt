import React, { useEffect, useRef, useState } from 'react';
import { gsap } from 'gsap';
import { ScrollTrigger } from 'gsap/ScrollTrigger';
import { TextPlugin } from 'gsap/TextPlugin';
import { Canvas, useFrame, useLoader } from '@react-three/fiber';
import { TextureLoader } from 'three/src/loaders/TextureLoader';
import { Sphere, Torus, Box } from '@react-three/drei';
import * as THREE from 'three';

gsap.registerPlugin(ScrollTrigger, TextPlugin);

const CinematicExperienceTemplate = ({ userData }) => {
  const containerRef = useRef();
  const titleRef = useRef();
  const subtitleRef = useRef();
  const linksRef = useRef();
  const [currentScene, setCurrentScene] = useState(0);
  
  useEffect(() => {
    const ctx = gsap.context(() => {
      // Cinematic intro sequence
      const tl = gsap.timeline();
      
      tl.from('.cinematic-overlay', {
        scaleX: 0,
        duration: 2,
        ease: 'power2.inOut'
      })
      .to('.cinematic-overlay', {
        scaleX: 0,
        transformOrigin: 'right',
        duration: 1.5,
        ease: 'power2.inOut'
      }, 2)
      .from('.avatar-3d', {
        scale: 0,
        rotationY: -720,
        duration: 2,
        ease: 'back.out(1.7)'
      }, 1)
      .from(titleRef.current, {
        y: 100,
        opacity: 0,
        duration: 1.5,
        ease: 'power3.out'
      }, 2.5)
      .from(subtitleRef.current, {
        text: '',
        duration: 2,
        ease: 'none'
      }, 3);

      // Scroll-triggered animations
      gsap.utils.toArray('.cinema-link').forEach((link, i) => {
        gsap.from(link, {
          x: i % 2 === 0 ? -200 : 200,
          opacity: 0,
          rotationY: i % 2 === 0 ? -90 : 90,
          duration: 1.5,
          ease: 'power2.out',
          scrollTrigger: {
            trigger: link,
            start: 'top 80%',
            end: 'bottom 20%',
            toggleActions: 'play none none reverse'
          }
        });
      });

      // Parallax effect for background elements
      gsap.to('.floating-geometry', {
        y: -100,
        rotation: 360,
        duration: 10,
        repeat: -1,
        ease: 'none'
      });

    }, containerRef);

    return () => ctx.revert();
  }, []);

  return (
    <div ref={containerRef} className="cinematic-container">
      {/* Cinematic Overlay */}
      <div className="cinematic-overlay" />
      
      {/* 3D Background Scene */}
      <div className="three-cinema-bg">
        <Canvas camera={{ position: [0, 0, 10], fov: 75 }}>
          <CinematicScene currentScene={currentScene} />
          <ambientLight intensity={0.3} />
          <spotLight position={[10, 10, 10]} angle={0.15} penumbra={1} />
        </Canvas>
      </div>

      {/* Floating Geometric Elements */}
      <div className="floating-geometry">
        {Array.from({ length: 8 }).map((_, i) => (
          <div
            key={i}
            className={`geometric-shape shape-${i % 4}`}
            style={{
              left: `${Math.random() * 100}%`,
              top: `${Math.random() * 100}%`,
              animationDelay: `${i * 0.5}s`,
              animationDuration: `${8 + Math.random() * 4}s`
            }}
          />
        ))}
      </div>

      <div className="cinema-content">
        {/* 3D Avatar Section */}
        <section className="hero-cinema">
          <div className="avatar-3d">
            <div className="avatar-container">
              <img src={userData.avatar} alt={userData.name} />
              <div className="hologram-effect" />
              <div className="scan-lines" />
            </div>
          </div>
          
          <h1 ref={titleRef} className="cinema-title">
            {userData.name}
          </h1>
          
          <p ref={subtitleRef} className="cinema-subtitle">
            {userData.bio}
          </p>

          {/* Scene Navigation */}
          <div className="scene-selector">
            {Array.from({ length: 3 }).map((_, i) => (
              <button
                key={i}
                className={`scene-btn ${currentScene === i ? 'active' : ''}`}
                onClick={() => setCurrentScene(i)}
              >
                Scene {i + 1}
              </button>
            ))}
          </div>
        </section>

        {/* Cinematic Links Section */}
        <section ref={linksRef} className="links-cinema">
          {userData.links.map((link, i) => (
            <CinematicLink
              key={link.id}
              link={link}
              index={i}
              onClick={() => window.open(link.url, '_blank')}
            />
          ))}
        </section>

        {/* Social Media Cinema */}
        <section className="social-cinema">
          <h2 className="social-title">Connect Across Dimensions</h2>
          <div className="social-grid">
            {userData.socialLinks.map((social, i) => (
              <a
                key={social.platform}
                href={social.url}
                className="social-portal"
                style={{ '--delay': `${i * 0.1}s` }}
              >
                <div className="portal-ring">
                  <div className="portal-icon">{social.icon}</div>
                  <div className="energy-particles">
                    {Array.from({ length: 12 }).map((_, j) => (
                      <div
                        key={j}
                        className="particle"
                        style={{
                          '--angle': `${j * 30}deg`,
                          '--delay': `${j * 0.1}s`
                        }}
                      />
                    ))}
                  </div>
                </div>
              </a>
            ))}
          </div>
        </section>
      </div>
    </div>
  );
};

// Cinematic Link Component
const CinematicLink = ({ link, index, onClick }) => {
  const linkRef = useRef();
  const [isHovered, setIsHovered] = useState(false);

  useEffect(() => {
    const element = linkRef.current;
    
    const handleMouseEnter = () => {
      setIsHovered(true);
      gsap.to(element, {
        scale: 1.05,
        rotationY: 10,
        z: 50,
        duration: 0.3,
        ease: 'power2.out'
      });
      
      gsap.to(element.querySelector('.link-glow'), {
        opacity: 1,
        scale: 1.2,
        duration: 0.3
      });
    };

    const handleMouseLeave = () => {
      setIsHovered(false);
      gsap.to(element, {
        scale: 1,
        rotationY: 0,
        z: 0,
        duration: 0.3,
        ease: 'power2.out'
      });
      
      gsap.to(element.querySelector('.link-glow'), {
        opacity: 0,
        scale: 1,
        duration: 0.3
      });
    };

    element.addEventListener('mouseenter', handleMouseEnter);
    element.addEventListener('mouseleave', handleMouseLeave);

    return () => {
      element.removeEventListener('mouseenter', handleMouseEnter);
      element.removeEventListener('mouseleave', handleMouseLeave);
    };
  }, []);

  return (
    <div
      ref={linkRef}
      className="cinema-link"
      onClick={onClick}
      style={{ '--index': index }}
    >
      <div className="link-glow" />
      <div className="link-frame">
        <div className="frame-corners">
          <div className="corner tl" />
          <div className="corner tr" />
          <div className="corner bl" />
          <div className="corner br" />
        </div>
        
        <div className="link-content">
          <div className="link-icon">
            {link.icon}
            <div className="icon-hologram" />
          </div>
          
          <div className="link-text">
            <h3>{link.title}</h3>
            <p>{link.description}</p>
          </div>

          <div className="access-indicator">
            <div className="indicator-line" />
            <span>ACCESS</span>
          </div>
        </div>
      </div>
      
      {/* Data streams */}
      <div className="data-streams">
        {Array.from({ length: 3 }).map((_, i) => (
          <div
            key={i}
            className="data-stream"
            style={{ '--stream-delay': `${i * 0.2}s` }}
          />
        ))}
      </div>
    </div>
  );
};

// 3D Cinematic Scene Component
const CinematicScene = ({ currentScene }) => {
  const meshRef = useRef();
  const groupRef = useRef();

  useFrame((state) => {
    if (groupRef.current) {
      groupRef.current.rotation.y = state.clock.elapsedTime * 0.1;
    }
    
    if (meshRef.current) {
      meshRef.current.rotation.x = Math.sin(state.clock.elapsedTime) * 0.2;
      meshRef.current.rotation.z = Math.cos(state.clock.elapsedTime * 0.5) * 0.1;
    }
  });

  const sceneConfigs = [
    { color: '#8b5cf6', geometry: 'sphere' },
    { color: '#ec4899', geometry: 'torus' },
    { color: '#06b6d4', geometry: 'box' }
  ];

  const config = sceneConfigs[currentScene];

  return (
    <group ref={groupRef}>
      {config.geometry === 'sphere' && (
        <Sphere ref={meshRef} args={[2, 64, 64]} position={[0, 0, -5]}>
          <meshStandardMaterial
            color={config.color}
            wireframe
            transparent
            opacity={0.6}
          />
        </Sphere>
      )}
      
      {config.geometry === 'torus' && (
        <Torus ref={meshRef} args={[2, 0.6, 16, 64]} position={[0, 0, -5]}>
          <meshStandardMaterial
            color={config.color}
            wireframe
            transparent
            opacity={0.6}
          />
        </Torus>
      )}
      
      {config.geometry === 'box' && (
        <Box ref={meshRef} args={[3, 3, 3]} position={[0, 0, -5]}>
          <meshStandardMaterial
            color={config.color}
            wireframe
            transparent
            opacity={0.6}
          />
        </Box>
      )}
      
      {/* Particle system */}
      {Array.from({ length: 100 }).map((_, i) => (
        <mesh
          key={i}
          position={[
            (Math.random() - 0.5) * 20,
            (Math.random() - 0.5) * 20,
            (Math.random() - 0.5) * 20
          ]}
        >
          <sphereGeometry args={[0.02, 8, 8]} />
          <meshBasicMaterial color={config.color} />
        </mesh>
      ))}
    </group>
  );
};

export default CinematicExperienceTemplate;
